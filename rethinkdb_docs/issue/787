Issue
  { issueClosedAt = Just 2015 (-06) (-30) 23 : 39 : 40 UTC
  , issueUpdatedAt = 2015 (-06) (-30) 23 : 39 : 40 UTC
  , issueEventsUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/787/events"
  , issueHtmlUrl =
      Just "https://github.com/rethinkdb/docs/issues/787"
  , issueClosedBy = Nothing
  , issueLabels = []
  , issueNumber = 787
  , issueAssignee =
      Just
        SimpleUser
          { simpleUserId = Id 467928
          , simpleUserLogin = N "chipotle"
          , simpleUserAvatarUrl =
              "https://avatars.githubusercontent.com/u/467928?v=3"
          , simpleUserUrl = "https://api.github.com/users/chipotle"
          , simpleUserType = OwnerUser
          }
  , issueUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueTitle = "Document emergency repair command"
  , issuePullRequest = Nothing
  , issueUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/787"
  , issueCreatedAt = 2015 (-06) (-09) 03 : 14 : 08 UTC
  , issueBody =
      Just
        "We need to document the new `emergency_repair` mode of `table.reconfigure()` for 2.1.\r\n\r\n##### Background\r\n\r\nNormally, failure recovery in RethinkDB works as follows: Suppose that some servers have died or have been isolated from the rest of the cluster. As long as more than half of the (voting) replicas for each shard of a table are still available, the table will automatically regain availability by failing over to the server that are still available. The admin can then either wait for the missing servers to come back online; or add new replacement servers by using the `reconfigure()` command or by writing to `rethinkdb.table_config`. Unlike in RethinkDB 2.0, there is no need to \"permanently remove\" the old servers from the cluster; the old servers can return later with no difficulty. During this whole process, the consistency/linearizability guarantees are preserved and the table never loses availability for more than a short time.\r\n\r\nHowever, this all assumes that more than half of the voting replicas are available for each shard. If half or more of the voting replicas for a shard are lost, then the normal recovery methods will not work. The user has two options: They can simply wait for the missing servers to come back, or they can run the emergency repair command.\r\n\r\n##### Syntax\r\n\r\nThe syntax is as follows:\r\n```js\r\nr.table(...).reconfigure({emergencyRepair: \"unsafe_rollback\" [, dryRun: <bool>]})\r\nr.table(...).reconfigure({emergencyRepair: \"unsafe_rollback_or_erase\" [, dryRun: <bool>]})\r\n```\r\nEmergency repair is effectively a separate command from the normal `reconfigure()` command, even though it uses the same term. So if the `emergencyRepair` optarg is provided, the normal `reconfigure()` optargs like `replicas`, `shards`, etc. are not allowed.\r\n\r\nNote that it's illegal to run `r.db(...).reconfigure({emergencyRepair: ...})`; the user must run it on each table one at a time, instead of running it on the entire database at once.\r\n\r\nSpecifying `emergencyRepair: null` is equivalent to not specifying `emergencyRepair` at all. For example, `table.reconfigure({emergencyRepair: null, shards: 2, replicas: 2})` is a perfectly valid command that's equivalent to `table.reconfigure({shards: 2, replicas: 2})`. This is mostly just for consistency; we don't expect people to use it very often.\r\n\r\nThe return value has the same format as for a regular `reconfigure()` command.\r\n\r\n##### Behavior\r\n\r\nThe emergency repair command examines each shard of the table, and puts it into one of three categories:\r\n1. More than half of the shard's voting replicas are still available; the shard is healthy.\r\n2. The shard is missing half or more of its voting replicas, but there is still at least one voting or non-voting replica available. So the shard can be repaired.\r\n3. The shard is missing all of its voting and non-voting replicas, so it is beyond repair.\r\n\r\nIf all of the shards are healthy, the emergency repair command raises an error, reporting that the table doesn't need to be repaired.\r\n\r\nFor each shard that can be repaired, the emergency repair command forcibly converts any unavailable voting replicas into non-voting replicas. Then, if all of the voting replicas were removed, it forcibly converts an arbitrary available non-voting replica into a voting replica. Normally, it's impossible to change the set of voting replicas unless a quorum of voting replicas is available; but the emergency repair command bypasses this safeguard.\r\n\r\nIf the `emergencyRepair` parameter was set to `\"unsafe_rollback\"`, then any shards that were beyond repair will be left alone. If all of the shards are either healthy or beyond repair, so there is nothing to do, the command will raise an error. If the `emergencyRepair` parameter was set to `\"unsafe_rollback_or_erase\"`, then the shards that are beyond repair will be destroyed and re-created from scratch. Any data that was on those shards before will be permanently lost; but the shards will be available for writing again.\r\n\r\nIf `dryRun` is set to `true`, then the table will not actually be changed, but the emergency repair command will report what would have been done via the `config_changes` field of the return value.\r\n\r\n##### Warnings\r\n\r\nThe emergency repair command is extremely dangerous. It should only be used as a last resort. It works by bypassing the normal safeguards that prevent people from losing or corrupting their data. It invalidates the linearizability guarantees that RethinkDB normally provides. In `unsafe_rollback_or_erase` mode, it can easily lose large chunks of data. Even in `unsafe_rollback` mode it can lose data; for example, if it converts a non-voting replica to a voting replica, that replica might not have a complete copy of the table's data yet."
  , issueState = "closed"
  , issueId = Id 86424232
  , issueComments = 2
  , issueMilestone =
      Just
        Milestone
          { milestoneCreator =
              SimpleUser
                { simpleUserId = Id 167416
                , simpleUserLogin = N "VeXocide"
                , simpleUserAvatarUrl =
                    "https://avatars.githubusercontent.com/u/167416?v=3"
                , simpleUserUrl = "https://api.github.com/users/VeXocide"
                , simpleUserType = OwnerUser
                }
          , milestoneDueOn = Nothing
          , milestoneOpenIssues = 0
          , milestoneNumber = 8
          , milestoneClosedIssues = 24
          , milestoneDescription = Nothing
          , milestoneTitle = "2.1"
          , milestoneUrl =
              "https://api.github.com/repos/rethinkdb/docs/milestones/8"
          , milestoneCreatedAt = 2015 (-03) (-30) 22 : 32 : 47 UTC
          , milestoneState = "closed"
          }
  }