IssueComment
  { issueCommentUpdatedAt = 2016 (-03) (-08) 22 : 56 : 36 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/comments/194006164"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/docs/issues/962#issuecomment-194006164"
  , issueCommentCreatedAt = 2016 (-03) (-08) 22 : 56 : 36 UTC
  , issueCommentBody =
      "@chipotle Here's a write up of some of the things that we should probably cover:\r\n\r\n__What is a RethinkDB proxy?__\r\n\r\nA RethinkDB proxy is a RethinkDB server that doesn't store any persistent state, but\r\nperforms certain aspects of query processing locally.\r\n\r\nA typical use case is running a RethinkDB proxy instance locally on each application\r\nserver (see figure TODO). We'll take a closer look at typical proxy setups below.\r\n\r\nTODO: Maybe insert a figure like the following one that compares a setup without and with proxies.\r\n  Specifically it should illustrate the idea of having the proxies run on the application\r\n  servers, with the application connecting directly to the proxy instead of to the\r\n  individual database servers.\r\n\r\n```\r\n | 1. Basic setup without proxies |\r\n ----------------------------------                                      \r\n   ____________________                    ________________                                              \r\n  |     App server 1   |                  |   DB server 1  |                                                  \r\n  |  _______________   |            ----->|                |==                       \r\n  | |  Application  |--|----------->|      ----------------  ||                         \r\n  |  ---------------   |            |                        ||                     \r\n  |                    |            |                        ||                    \r\n   --------------------             |      ________________  ||                                       \r\n                        Client conn.|     |   DB server 2  | || Cluster connections\r\n   ____________________             |---->|                |=||                                                \r\n  |     App server 2   |            |      ----------------  ||                                               \r\n  |  _______________   |            |                        ||                          \r\n  | |  Application  |--|----------->|      ________________  ||                 \r\n  |  ---------------   |            |     |   DB server 3  | ||                     \r\n  |                    |            ----->|                |==                     \r\n   --------------------                    ----------------   \r\n                                                    \r\n                                                                                      \r\n  | 2. Setup with proxies        |\r\n  --------------------------------                                                    \r\n   ____________________                    ________________                                              \r\n  |     App server 1   |                  |   DB server 1  |                                                  \r\n  |  _______________   |                  |                |==                       \r\n  | |  Application  |  |                   ----------------  ||                         \r\n  |  ---------------   |                                     ||                     \r\n  |  _______|_______   |                                     ||                    \r\n  | |     Proxy     |==|=====================================||                    \r\n   --------------------                    ________________  ||                                       \r\n                                          |   DB server 2  | || Cluster connections\r\n   ____________________                   |                |=||                                                \r\n  |     App server 2   |                   ----------------  ||                                               \r\n  |  _______________   |                                     ||                          \r\n  | |  Application  |  |                   ________________  ||                 \r\n  |  ---------------   |                  |   DB server 3  | ||                     \r\n  |  _______|_______   |                  |                |=||                    \r\n  | |     Proxy     |==|=============      ----------------  ||     \r\n   --------------------             \\=========================                              \r\n                                                                                  \r\n```                                                                                  \r\n\r\nMore precisely, a proxy:\r\n* Cannot become a replica for any tables\r\n* Does not participate in write or failover majorities (i.e. it cannot be used as an\r\n  to enable auto-failover in smaller clusters)\r\n* Does not have a server name or any server tags\r\n* Does not show up in certain system tables, including the `server_config` table\r\n\r\nHowever, a RethinkDB proxy still provides the following features:\r\n* It listens for client connections.\r\n* It can join a cluster and connects directly to all servers in the cluster, so it can\r\n  efficiently route read and write operations directly to the responsible replicas.\r\n* It parses, interprets and processes queries. While most work will typically be\r\n  passed on to the nodes that host the table data, certain operations will be performed\r\n  on the proxy itself (for examle non-indexed `orderBy`, operations on arrays etc.).\r\n* It manages changefeeds locally, allowing deduplication of change notifications within\r\n  the cluster.\r\n\r\nTo start a RethinkDB proxy, you can run `rethinkdb proxy -j <other server>`. See TODO for\r\nmore details on this command.\r\n\r\n__When should I use a RethinkDB proxy?__\r\n\r\nPrimary use cases include:\r\n* Scaling changefeeds.\r\n* Reducing latencies within the cluster.\r\n* Improving throughput of queries where the bottleneck lies in certain aspects of the\r\n  query processing, such as query parsing or expensive array-based operations.\r\n\r\nWe will see in the next section how proxy servers can achieve these objectives.\r\n\r\n__How can a proxy improve performance?__\r\n\r\nWith a proxy running locally on each application\r\nserver, you can avoid an additional network hop by facilitating a proxy's intelligent\r\nrouting logic. The proxy always knows which database server holds the data for a\r\nparticular request, and can route the request directly to the responsible server.\r\nCompare that to a client connecting directly to a database server.\r\nSince the application usually doesn't know which database server has the data needed\r\nfor a particular query, the server handling the query will need to forward the request\r\nfurther to obtain the data. Two network hops will be required in this scenario, instead\r\nof just one with the local proxy.\r\n\r\nSince proxies also perform certain query processing steps themselves, they can also help\r\nscaling those queries more easily. Adding a proxy to a cluster is often easier than\r\nadding a full database server. The proxy will not only handle decoding the client\r\nrequests and encoding the query responses, but will also perform a number of calculations\r\nlocally. These specifically include many ReQL commands that operate on in-memory arrays,\r\nas well as commands that work on aggregated data (e.g. `orderBy` without an index,\r\ncommands following an `ungroup` operation etc.).\r\n\r\n_Changefeeds_\r\n\r\nIn addition to regular queries, a proxy can also be a very powerful tool for scaling\r\nchangefeed-heavy applications.\r\n\r\nA proxy will manage changefeeds locally, and reduce the overhead (RAM, CPU and network)\r\non the database servers. For any write operation to a table with active changefeeds,\r\na database server only sends a single network message to a given proxy. If for example\r\n10,000 clients are listening through a proxy to changes on a particular table, the\r\ndatabase server(s) hosting the table will send a single network message to the proxy when\r\nthe table is changed. The proxy then takes care of forwarding the change message to all\r\n10,000 clients locally.\r\n\r\nThis even works if the clients are listening to different selections on the table, such\r\nas when using the query `r.table('test').getAll(val, {index: \"idx\"}).changes()` with\r\ndifferent values `val` for each changefeed. The proxy will receive one message from the\r\ndatabase servers for every write to the table `'test'`, and will check locally which\r\nchangefeeds are affected by this change.\r\n\r\n__How do I run it?__\r\n\r\nA proxy has fewer requirements to the system's hardware compared to a regular database\r\nserver. In particular, it doesn't require fast storage and it uses less RAM because it\r\ndoesn't need to maintain a local data cache.\r\n\r\nThat being said, proxies still benefit from fast CPUs, and require enough RAM to process\r\nyour application's queries. 256 MB of available RAM is often enough for simple queries\r\nand moderate query throughput. However complex queries and/or a high number of concurrent\r\noperations (including a high number of open changefeeds) might require additional\r\nresources for the proxy server.\r\n\r\nNote that in contrast to a regular client that can connect to a single server, a proxy\r\nserver must be able to connect directly to all database servers on their intra-cluster\r\nports (port 29015 by default). If a proxy is unable to connect to all database servers,\r\nsome tables might become inaccessible for the proxy and queries using those will fail.\r\n\r\nIf all requirements are met, you can run a proxy through the `rethinkdb proxy` command.\r\nSee TODO for details.\r\n\r\nTODO: Mention/Describe rethinkdb/rethinkdb#5138 once available\r\n\r\nTODO: Maybe describe a few \"best practice\" scenarios in more detail. E.g.\r\n  \"proxy running on each app server\" vs. \"adding a central pool of proxies to a cluster\"."
  , issueCommentId = 194006164
  }