IssueComment
  { issueCommentUpdatedAt = 2015 (-03) (-24) 04 : 17 : 29 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 17789
        , simpleUserLogin = N "gchpaco"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/17789?v=3"
        , simpleUserUrl = "https://api.github.com/users/gchpaco"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/comments/85331379"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/docs/issues/683#issuecomment-85331379"
  , issueCommentCreatedAt = 2015 (-03) (-24) 04 : 12 : 27 UTC
  , issueCommentBody =
      "Preliminary take on it here.\r\n\r\n# Accessing RethinkDB using Tornado\r\n\r\nNew in 2.0 is integration with the [Tornado web framework](http://www.tornadoweb.org/).  This permits users to recieve updates from several requests asynchronously, and is particularly useful for multiple changefeeds.\r\n\r\n## Basic Usage\r\n\r\nThe first task is to tell the driver which event loop you are using.  We intend to support multiple event loops in time, although presently we only support Tornado.  This is done through the `r.set_loop_type` call, as follows:\r\n\r\n```py\r\nimport rethinkdb as r\r\nfrom tornado import ioloop, gen\r\nfrom tornado.concurrent import Future\r\n\r\nr.set_loop_type(\"tornado\")\r\n```\r\n\r\nAfter this, `r.connect` will return a Tornado `Future`, as will `r.run`.  We have designed the API assuming you will prefer to use Tornado's coroutine support.\r\n\r\nA simple skeleton framework for testing is as follows:\r\n\r\n```py\r\n@gen.coroutine\r\ndef run_coro(coroutine, *args, **kwargs):\r\n    conn = yield r.connect(host=\"...\")\r\n    yield coroutine(conn, *args, **kwargs)\r\n\r\nif __name__ == \"__main__\":\r\n    ioloop.IOLoop.instance().run_sync(functools.partial(run_coro, example_coroutine))\r\n```\r\n\r\n#### Example 1: simple use\r\n\r\n```py\r\n@gen.coroutine\r\ndef single_row(connection):\r\n    # Insert some data.\r\n    yield r.table('test').insert([{\"id\": 0}, {\"id\": 1}, {\"id\": 2}]).run(connection)\r\n    # Print every row in the table.\r\n    row = yield r.table('test').get(0).run(connection)\r\n    print(row)\r\n```\r\n\r\nWill print:\r\n\r\n```py\r\n{u'id': 0}\r\n```\r\n\r\n#### Example 2: using a cursor\r\n\r\n```py\r\n@gen.coroutine\r\ndef exercise_db(connection):\r\n    # Insert some data.\r\n    yield r.table('test').insert([{\"id\": 0}, {\"id\": 1}, {\"id\": 2}]).run(connection)\r\n    # Print every row in the table.\r\n    for future in (yield r.table('test').order_by(index='id').run(connection)):\r\n        item = yield future\r\n        print(item)\r\n```\r\n\r\nWill print:\r\n\r\n```py\r\n{u'id': 0}\r\n{u'id': 1}\r\n{u'id': 2}\r\n```\r\n\r\n## Basic Error Handling\r\n\r\nIf there is an error during an asynchronous operation, the relevant `yield` statement will throw an exception as normal.  This can happen immediately (for example, you might reference a table that doesn't exist) or you might get large amounts of data before the error (for example, your network might be disrupted after the connection is established).\r\n\r\nOne error in particular is notable.  If you have a coroutine set to consume a changefeed indefinitely, and the connection closes, the coroutine will experience a `RqlRuntimeError`.\r\n\r\n#### Example 1: re-thrown errors\r\n\r\n```py\r\n@gen.coroutine\r\ndef bad_table(connection):\r\n    yield r.table('non_existent').run(connection)\r\n```\r\n\r\nWill produce an error:\r\n\r\n```\r\nTraceback (most recent call last):\r\n... elided ...\r\nrethinkdb.errors.RqlRuntimeError: Table `test.non_existent` does not exist. in:\r\nr.table('non_existent')\r\n^^^^^^^^^^^^^^^^^^^^^^^\r\n```\r\n\r\n#### Example 2: catching errors in the coroutine\r\n\r\n```py\r\n@gen.coroutine\r\ndef catch_bad_table(connection):\r\n    try:\r\n        yield r.table('non_existent').run(connection)\r\n    except r.RqlRuntimeError:\r\n        print(\"Saw error\")\r\n```\r\n\r\nWill print:\r\n\r\n```\r\nSaw error\r\n```\r\n\r\n## Subscribing to changefeeds\r\n\r\nChangefeeds can be used like normal streams, but we anticipate one of the most common uses for the asynchronous database API is for handling multiple change feeds.  This is possible by scheduling callbacks.  As an example, consider this changefeed handler:\r\n\r\n```py\r\n@gen.coroutine\r\ndef print_cfeed_data(connection, table):\r\n    feed = yield r.table(table).changes().run(connection)\r\n    try:\r\n        for cursor in feed:\r\n            item = yield cursor\r\n            print(item)\r\n    except r.RqlRuntimeError as e:\r\n        # termination of connection\r\n        print(\"Saw error\", e)\r\n```\r\n\r\nWe can schedule it on the tornado IO loop with this code:\r\n\r\n```py\r\nioloop.IOLoop.add_callback(print_cfeed_data, connection, table)\r\n```\r\n\r\nAfter which point it will run in the background, printing out changes.  We can then alter the table, and the changes will be noticed.\r\n\r\nA larger example here is in order.  Consider this setup:\r\n\r\n```py\r\nclass BuggyChangefeedNoticer(object):\r\n    def __init__(self, connection):\r\n        self._connection = connection\r\n    @gen.coroutine\r\n    def print_cfeed_data(self, table):\r\n        feed = yield r.table(table).changes().run(self._connection)\r\n        try:\r\n            for cursor in feed:\r\n                item = yield cursor\r\n                print(\"Seen on table %s: %s\" % (table, item))\r\n        except r.RqlRuntimeError as e:\r\n            # termination of connection\r\n            print(\"Saw error\", e)\r\n    @gen.coroutine\r\n    def table_write(self, table):\r\n        for i in range(10):\r\n            yield r.table(table).insert({'id': i}).run(self._connection)\r\n    @gen.coroutine\r\n    def exercise_changefeeds(self):\r\n        loop = ioloop.IOLoop.current()\r\n        loop.add_callback(self.print_cfeed_data, 'a')\r\n        loop.add_callback(self.print_cfeed_data, 'b')\r\n        yield [self.table_write('a'), self.table_write('b')]\r\n    @classmethod\r\n    @gen.coroutine\r\n    def run(cls, connection):\r\n        noticer = cls(connection)\r\n        yield noticer.exercise_changefeeds()\r\n```\r\n\r\nThis code contains a subtle bug, which we can observe looking at the output:\r\n\r\n```\r\n>>> go_with(ChangefeedNoticer.run)\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 1}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 2}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 3}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 4}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 5}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 3}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 4}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 6}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 5}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 7}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 6}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 8}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 7}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 9}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 8}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 9}}\r\n```\r\n\r\nNote that we missed the insertion of `0` in both tables, and some other values in table `b`, too; the first one we saw there was `3`.  This is because Tornado's `add_callback` does not guarantee when the callback will be run, just that it will be done 'soon'.  As a result our changefeeds may not created before the write starts.  Fixing it is relatively straightforward:\r\n\r\n```py\r\nclass FixedChangefeedNoticer(object):\r\n    def __init__(self, connection):\r\n        self._connection = connection\r\n    @gen.coroutine\r\n    def print_cfeed_data(self, table):\r\n        feed = yield r.table(table).changes().run(self._connection)\r\n        try:\r\n            self._feeds_ready[table].set_result(True)\r\n            for cursor in feed:\r\n                item = yield cursor\r\n                print(\"Seen on table %s: %s\" % (table, item))\r\n        except r.RqlRuntimeError as e:\r\n            # termination of connection\r\n            print(\"Saw error\", e)\r\n    @gen.coroutine\r\n    def table_write(self, table):\r\n        for i in range(10):\r\n            yield r.table(table).insert({'id': i}).run(self._connection)\r\n    @gen.coroutine\r\n    def exercise_changefeeds(self):\r\n        self._feeds_ready = {'a': Future(), 'b': Future()}\r\n        loop = ioloop.IOLoop.current()\r\n        loop.add_callback(self.print_cfeed_data, 'a')\r\n        loop.add_callback(self.print_cfeed_data, 'b')\r\n        yield self._feeds_ready\r\n        yield [self.table_write('a'), self.table_write('b')]\r\n    @classmethod\r\n    @gen.coroutine\r\n    def run(cls, connection):\r\n        noticer = cls(connection)\r\n        yield noticer.exercise_changefeeds()\r\n```\r\n\r\nHere we have used Tornado's `Future`s to signal when the changefeeds have been set up, and only then proceed with inserting rows.  Now we see this output:\r\n\r\n```py\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 0}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 0}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 1}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 1}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 2}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 2}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 3}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 3}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 4}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 4}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 5}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 6}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 5}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 7}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 6}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 8}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 7}}\r\nSeen on table a: {u'old_val': None, u'new_val': {u'id': 9}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 8}}\r\nSeen on table b: {u'old_val': None, u'new_val': {u'id': 9}}\r\n```\r\n"
  , issueCommentId = 85331379
  }