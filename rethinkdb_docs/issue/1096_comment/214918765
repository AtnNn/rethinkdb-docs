IssueComment
  { issueCommentUpdatedAt = 2016 (-04) (-26) 23 : 29 : 53 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 159819
        , simpleUserLogin = N "cefn"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/159819?v=3"
        , simpleUserUrl = "https://api.github.com/users/cefn"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/comments/214918765"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/docs/issues/1096#issuecomment-214918765"
  , issueCommentCreatedAt = 2016 (-04) (-26) 23 : 29 : 53 UTC
  , issueCommentBody =
      "BTW the V8 debugger has more information than merely console.log applied to the function. It's for that reason that using named functions is preferred - this is visible in the debugger. Literally, wherever you currently have...\r\n\r\n```\r\nvar fun = function(){\r\n   ///something\r\n}\r\n```\r\n...do instead...\r\n```\r\nvar fun = function whatItDoes(){\r\n   ///something\r\n}\r\n```\r\n...or eliminate an unnecessary entry in the namespace by...\r\nfunction whatItDoes(){\r\n   ///something\r\n}\r\n\r\nThe extra name information 'whatItDoes' is retained in the debugger for inspection and has helped a great deal when investigating stacks and such.\r\n\r\n# My learning\r\n\r\nIn terms of my learning, I'm probably not a good case, as I fundamentally understood what you were trying to do (creating functions as factories for query structures to be bound later) but was just trying to understand which of the various possible mappings between functions and bound operations was in use when. \r\n\r\nBy contrast for many learners, the overall model would need to be explained in some detail - differentiating the manipulation of data from the future-binding, as these easily blur into each other even when you are aware and trying to keep track.\r\n\r\nI found it frustrating that having visited a specific function such as https://www.rethinkdb.com/api/javascript/update/ , it was impossible either to browse the others available (all left-menus are collapsed) or to search for them (there is no search functionality). Either one or both of these should be available. A single list of all operations would be useful (having an exhaustive list helps me be sure I have learned all the operations).\r\n\r\nMy initial learning was centred on the updating and querying of array subdocument structures (referencing the introductory information about nested fields and secondary indexes) and working out from there into a broader understanding of ReQL by scanning the API, then focusing on individual operations on a case-by-case basis as I implemented my server-side components. Inherently the apps I'm building are a relational database and the nature of 'joins' would determine the feasibility of any host platform and denormalization strategy. I have been very pleased with RethinkDB in this regard.\r\n\r\nWith Mongo, every form of data normalization I attempted caused a conflict with one or both of... \r\n* server-side, indexed querying\r\n* document-oriented data structures.\r\n\r\nI wanted my data structure to be document-oriented and with embedded document structures, so it could be debugged by exploring the database (debugging is very hard when in fully-normalised form - where reconstructing the full application structures relies on human-impenetrable index joins).\r\n\r\nI also wanted to be able to hit decent scaling numbers, avoiding any application-level querying (where a whole chunk of the database ends up client-side to work around limitations in Mongo aggregation - which I think is hidden in some schema-oriented object-modelling implementations). My worry here isn't raw performance, but rather non-linearity. I'm happy for RethinkDB to always be four times as slow as Mongo, as long as it ensures that I can easily create indexed joins so that retrieval isn't slowed as the database gets bigger.\r\n\r\nIn Mongo I kept having to reengineer the document structures for each new query to be possible/efficient. Even where Mongo aggregations were expressive enough and performant enough to perform the 'join' I needed, they became impenetrable thickets which I couldn't imagine anyone maintaining or extending.\r\n\r\nAfter investigating examples, and building and running simple test cases through Webstorm 11 V8 debugging, it became clear that with RethinkDb I could construct multi-indexes and have them queried efficiently and with low latency server-side, I could figure out my preferred queries as and when I needed them, and that they would be comprehensible to read. \r\n\r\nI can't claim to know ReQL, yet, although I've been very pleased and impressed with the attention to detail and the overall common-sense approach which has been taken."
  , issueCommentId = 214918765
  }