IssueComment
  { issueCommentUpdatedAt = 2014 (-09) (-05) 02 : 26 : 24 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 505365
        , simpleUserLogin = N "danielmewes"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/505365?v=3"
        , simpleUserUrl = "https://api.github.com/users/danielmewes"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/comments/54394198"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/docs/issues/446#issuecomment-54394198"
  , issueCommentCreatedAt = 2014 (-09) (-04) 01 : 53 : 51 UTC
  , issueCommentBody =
      "Ok, here is a (hopefully complete) description of geometry features in ReQL.\r\nThis is meant to serve as an internal reference and as a basis for @chipotle to write some actual user documentation (API docs and maybe an additional article for our documents?).\r\n\r\n\r\n\r\n_GENERAL_\r\n- Coordinates\r\n    All geometry in RethinkDB lives on the surface of a sphere in three-dimensional space.\r\n    As a consequence, coordinates are two dimensional. Positions on the sphere's surface are\r\n    addressed by a pair of latitude and longitude (in this order. That is different from\r\n    GeoJSON, which uses longitude, latitude). The latitude is a real (floating point) number\r\n    between -90 and 90. The longitude is between -180 and 180. The longitudes 180 and -180\r\n    are equivalent, while latitudes -90 and 90 are actually on opposite sides of the globe\r\n    (the one is at the south pole, the other at the north pole).\r\n    See http://en.wikipedia.org/wiki/Geographic_coordinate_system for details.\r\n\r\n- Geometric primitives and the GEOMETRY type\r\n    ReQL supports the following geometric objects:\r\n    - Points - just a single coordinate pair\r\n    - Lines - A sequence of coordinate pairs, at least two of them.\r\n    - Polygons - Exactly one outer shell, and an arbitrary number of holes. The shell is\r\n      a line which first and last coordinate pair are equal, and which doesn't intersect\r\n      with itself. The holes are like shells, but each hole must be completely contained\r\n      in the shell minus all other holes. The set of points that defines the polygon is\r\n      the set of all points \"inside\" the shell, with points inside of any of the holes\r\n      cut out.\r\n\r\n    A new ReQL pseudo type \"GEOMETRY\" is introduced to represent any of these geometric objects.\r\n\r\n- Lines between two points\r\n    In contrast to Euclidean geometry, \"lines\" between two points on the surface of a sphere\r\n    are not straight. In ReQL a line between two points is given by the shortest path\r\n    over the sphere's surface. Such lines are commonly known as \"Geodesics\".\r\n    See http://en.wikipedia.org/wiki/Geodesic for details.\r\n    It follows that two connected points must not be antipodal (e.g. one at lat = -90,\r\n    the other one at lat = 90), or else the line connecting them is not defined.\r\n    (ReQL might or might not trigger an error if such a line is constructed, depending on\r\n    context. If it doesn't trigger an error, it picks one of the infinitely many possible\r\n    geodesics that connect the points, and the results of intersection / inclusion tests\r\n    will be undefined).\r\n    Lines and Polygons are defined in terms geodesics.\r\n    Note that we assume a perfect sphere for this. The earth is not a perfect sphere,\r\n    but comes close to it. Especially when the distance between two points is short compared\r\n    to earth's radius, the spherical geodesic will be practically identical to the shortest\r\n    path assuming a (more exact) elliptical model of earth's geometry.\r\n    \r\n- Distances\r\n    Distances between two points in ReQL are calculated assuming an ellipsoid earth.\r\n    This is a refinement over the earth as a sphere model. The distance between two points\r\n    is defined as the length of the shortest path along the ellipsoid's surface that connects\r\n    both points. See http://en.wikipedia.org/wiki/Geodesics_on_an_ellipsoid for details.\r\n    Computing such distances is not trivial. RethinkDB uses Karney's algorithm introduced in\r\n    http://link.springer.com/article/10.1007%2Fs00190-012-0578-z This is a state of the art\r\n    algorithm that is relatively fast, handles corner cases well and is highly exact.\r\n\r\n    All ReQL functions that operate with distances accept two optional arguments:\r\n    `geo_system` (`geoSystem` in JS): The reference ellipsoid to use. Possible values are:\r\n        \"WGS84\" and \"unit_sphere\". The default is \"WGS84\", which is a common standard for\r\n        earth's geometry http://en.wikipedia.org/wiki/World_Geodetic_System\r\n        \"unit_sphere\" assumes a perfect sphere of radius 1 meter.\r\n    `unit`: The distance unit to use. Possible values are: \"m\" - meters, \"km\" - kilometers,\r\n        \"mi\" - international miles, \"nm\" - nautical miles, \"ft\" - international feet.\r\n        The default is \"m\". All distances that are passed into a ReQL term that accepts this\r\n        argument will be interpreted in the corresponding unit, and results - if they contain\r\n        distances - will be given in the unit.\r\n\r\n\r\n_GEOSPATIAL INDEXES_\r\n- How to create one?\r\n    A geospatial index is created similarly to a regular index, however with an the optional\r\n    argument \"geo\" set to true. E.g.\r\n    r.table('t1').indexCreate('geometry', {geo: true})\r\n    This command creates a geospatial index over the field `geometry` on table `t1`.\r\n    Similar to regular indexes, geospatial indexes can be created over arbitrary deterministic\r\n    ReQL functions. It's also possible to combine the `multi` flag for creating a multi index\r\n    with the `geo` flag.\r\n\r\n- Which operations are applicable?\r\n    The following ReQL terms can operate with geospatial indexes: `getIntersecting`, `getNearest`\r\n    (and of course `indexStatus`, `indexWait`, `indexDrop`, `indexList`)\r\n    Trying to use a geospatial index with other terms such as `getAll`, `orderBy` or `between`\r\n    results in an error.\r\n    At the same time, `getIntersecting` and `getNearest` can only be used with a geospatial\r\n    index. Using those commands without an index at all or with a non-geospatial (regular)\r\n    secondary index results in an error.\r\n\r\n- What happens with non-geometric objects?\r\n    If there are documents in the table that have a value for the indexed field which is not\r\n    of type GEOMETRY, those documents will be ignored by a geospatial index.\r\n\r\n- What happens if I insert a geo object into a non-geo index?\r\n    Documents that have a value of type GEOMETRY for a field indexed by a regular secondary\r\n    index will be included in the index, but their ordering is rather arbitrary. In fact\r\n    such documents will be sorted within the index as if they were just JSON objects.\r\n\r\n\r\n_ReQL TERMS_\r\n- r.geojson(geojson) : OBJECT -> GEOMETRY\r\n    The r.geoJson term converts a given GeoJSON object into a ReQL GEOMETRY item.\r\n    GeoJSON is a widely used standard for representing geometrical data.\r\n    See http://geojson.org/ for more details.\r\n    Out of the GeoJSON geometry types, r.geojson supports the Point, LineString and\r\n    Polygon types. MultiPoint, MultiLineString and MultiPolygon are not supported.\r\n    (a work-around is storing multiple single Points/Lines/Polygons in an array and\r\n    using a geospatial multi-index for indexing them)\r\n    The following additional restrictions exist: Only longitude/latitude coordinate pairs\r\n    are supported. Cartesian coordinates are not. Furthermore, GeoJSON objects that specify\r\n    an altitude in addition to longitude and latitude are rejected by r.geoJson.\r\n    GeoJSON objects that specify their own coordinate reference system (CRS) are rejected\r\n    as well.\r\n    \r\n    Note that if you look at a ReQL GEOMETRY object in the Data Explorer or another driver,\r\n    you will see that its internal representation is actually GeoJSON. However it will have\r\n    an additional $reql_type$ field to identify it as a ReQL GEOMETRY object.\r\n    r.geoJson adds that $reql_type$ field, and makes sure that the geometry is valid\r\n    within the bounds given by ReQLs geometry implementation.\r\n\r\n- geometry.to_geojson() : GEOMETRY -> OBJECT\r\n    (JS: toGeojson)\r\n    The opposite of r.geojson. Takes a ReQL GEOMETRY object and turns it into a valid\r\n    GeoJSON object.\r\n\r\n- r.point(lat, lon) : NUMBER, NUMBER -> GEOMETRY\r\n    Constructs a ReQL GEOMETRY object of type point at the provided coordinates. See the\r\n    \"coordinates\" section above for details.\r\n\r\n- r.line(p1, p2, ..., pn) : GEOMETRY|ARRAY, ..., GEOMETRY|ARRAY -> GEOMETRY\r\n    Constructs a ReQL GEOMETRY object of type line from the given vertices. The coordinates\r\n    can be given in one of two ways:\r\n    1. r.line([lat1, lon1], ..., [latn, lonn]), i.e. a sequence of arrays each having two\r\n       numbers.\r\n    2. r.line(r.point(lat1, lon1), ..., r.point(latn, lonn)), i.e. a sequence of GEOMETRY\r\n       objects of type point.\r\n\r\n- r.polygon(p1, p2, ..., pn) : GEOMETRY|ARRAY, ..., GEOMETRY|ARRAY -> GEOMETRY\r\n    Same as r.line, but constructs a polygon instead that has the provided outer shell.\r\n    The given shell does not have to be closed. If p1 != pn, r.polygon will close the shell\r\n    implicitly by connecting pn to p1.\r\n    Similar to r.line, each point can be given either as [lat, lon] or as a GEOMETRY object\r\n    of type point.\r\n    Note that r.polygon cannot construct polygons with holes in them. The `sub` can be used\r\n    to create polygons with holes (see below).\r\n\r\n- r.circle(center, radius) : GEOMETRY|ARRAY, NUMBER {num_vertices:NUMBER, geo_system:STRING, unit:STRING, fill:BOOL} -> GEOMETRY\r\n    Constructs either a line or a polygon approximating a circle of `radius` around\r\n    `center`. The approximation uses `num_vertices` (numVertices in JS) vertices, with\r\n    32 being the default. Those vertices are placed at a distance of `radius` around\r\n    `center`, so to be precise the resulting polygon/line will have an exradius of `radius`.\r\n    If `fill` is true (default), a polygon is constructed. Otherwise a line is constructed.\r\n    The usual opt args for commands that deal with distances are supported. See \"distances\"\r\n    under GENERAL.\r\n\r\n- geometry.fill() : GEOMETRY -> GEOMETRY\r\n    Takes a line and creates a polygon with the line as its shell. Behaves just as if the\r\n    vertices of the line had been given to `r.polygon`.\r\n\r\n- geometry1.distance(geometry2) : GEOMETRY, GEOMETRY {geo_system:STRING, unit:STRING} -> GEOMETRY\r\n    Computes the distance between a point and another geometrical object, as described under\r\n    \"dinstances\" in GENERAL. At least one out of `geometry1` and `geometry2` must be a point.\r\n    If the other argument is a line or polygon, the projection of the point onto that\r\n    line/polygon will be computed first, assuming a perfect sphere model. The distance\r\n    between the point and its projection onto the line/polygon is then computed using the\r\n    more precise ellipsoid model. If lines/polygons are huge compared to earth's radius\r\n    and the distance between the point and the line/polygon is huge compared to earth's radius,\r\n    the results of `distance` should be considered approximate, since the projection might\r\n    be imprecise due to its simplified perfect-sphere assumption.\r\n    The usual opt args for commands that deal with distances are supported.\r\n\r\n- geometry1.intersects(geometry2) : GEOMETRY, GEOMETRY -> BOOL\r\n                                  | Sequence, GEOMETRY -> Sequence\r\n    Tests whether `geometry1` intersects with `geometry2`, i.e. if they have any point(s) in common.\r\n    When applied to a sequence, `intersects` works as a filter.\r\n\r\n- geometry1.includes(geometry2) : GEOMETRY, GEOMETRY -> BOOL\r\n                                | Sequence, GEOMETRY -> Sequence\r\n    Tests whether `geometry2` is completely contained within `geometry1`. `geometry1` must be\r\n    a polygon, while `geometry2` can be an arbitrary GEOMETRY object.\r\n    When applied to a sequence, `includes` works as a filter.\r\n\r\n- table.get_intersecting(geometry) : TABLE, GEOMETRY {index:STRING} -> StreamSelection\r\n    (JS: getIntersecting)\r\n    The `index` opt arg is mandatory and must correspond to a geospatial index.\r\n    `get_intersecting` uses a geospatial index to find\r\n    documents that intersect with `geometry` on the indexed field. It is semantically\r\n    equivalent to `table.filter(r.row(\"indexedField\").intersects(geometry))`.\r\n    Note that the total number of results that `get_intersecting` can return is limited by\r\n    the array size limit (default 100,000, can be changed through the opt arg `array_limit`\r\n    I think). If it encounters more results, an error will be thrown.\r\n\r\n- table.get_nearest(point) : TABLE, GEOMETRY|ARRAY {index:STRING, max_results:NUM, max_dist:NUM, geo_system:STRING, unit:STRING} -> ARRAY\r\n    (JS: getNearest)\r\n    The `index` opt arg is mandatory and must correspond to a geospatial index.\r\n    `get_nearest` uses the given index to find documents in `table` that are close to\r\n    `point`. `point` can be specified as either an array with latitude and longitude, or\r\n    as a GEOMETRY of type point. The distance definition is equivalent to the one used by\r\n    the `distance` term (see above). The result of `get_nearest` is an array of objects,\r\n    where each object has the structure `{dist: NUMBER, doc: OBJECT}` where `dist` is the\r\n    distance between `point` and the document in the specified unit (default: meters),\r\n    and `doc` is the actual document from `table`.\r\n    Results in the array are sorted in ascending order by their `dist` fields.\r\n    A maximum of `max_results` (JS: `maxResults`, default 100) are returned, and a maximal distance of\r\n    `max_dist` (JS: `maxDist`, default 100 km ~ 62 miles) is searched.\r\n    The usual opt args for commands that deal with distances are supported.\r\n\r\n- polygon1.polygon_sub(polygon2) : GEOMETRY, GEOMETRY -> GEOMETRY\r\n    (JS: polygonSub)\r\n    Both `polygon1` and `polygon2` must be polygons.\r\n    `polygon2` must only have a shell and no holes, and it must be completely contained \r\n    in `polygon1`.\r\n    Constructs a new polygon which is the same as `polygon1`, but with `polygon2` cut out\r\n    as a hole. This is the only way in ReQL to construct polygons with holes in them\r\n    (apart from `r.geojson`)\r\n"
  , issueCommentId = 54394198
  }