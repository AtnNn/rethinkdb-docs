IssueComment
  { issueCommentUpdatedAt = 2015 (-06) (-09) 01 : 49 : 32 UTC
  , issueCommentUser =
      SimpleUser
        { simpleUserId = Id 316661
        , simpleUserLogin = N "timmaxw"
        , simpleUserAvatarUrl =
            "https://avatars.githubusercontent.com/u/316661?v=3"
        , simpleUserUrl = "https://api.github.com/users/timmaxw"
        , simpleUserType = OwnerUser
        }
  , issueCommentUrl =
      "https://api.github.com/repos/rethinkdb/docs/issues/comments/110194224"
  , issueCommentHtmlUrl =
      "https://github.com/rethinkdb/docs/issues/770#issuecomment-110194224"
  , issueCommentCreatedAt = 2015 (-06) (-09) 01 : 48 : 43 UTC
  , issueCommentBody =
      "This document pertains to RethinkDB 2.1.\r\n\r\n#### Consistency and durability settings\r\n\r\nThere are three settings that control consistency and durability: `write_acks`, `durability`, and `read_mode`.\r\n\r\n##### Write acks\r\n\r\n`write_acks` can be set per-table via `rethinkdb.table_config`.\r\n\r\nThe possible values are:\r\n* `\"majority\"`: Writes will return once have been written to a majority of replicas (not counting non-voting replicas). This is the default.\r\n* `\"single\"`: Writes will return once they have been written to at least one replica.\r\n\r\n##### Durability\r\n\r\n`durability` can be set per-table via `rethinkdb.table_config` or per-query via an optarg to `.update()`, `.insert()`, etc. The per-table setting is only used if no per-query value is specified.\r\n\r\nThe possible values are:\r\n* `\"hard\"`: Writes are not considered \"written to a replica\" until they are safely on the replica's disk, secure against power failure. This is the default.\r\n* `\"soft\"`: Writes are considered \"written to a replica\" once they have been recorded in memory on the replica.\r\n\r\n##### Read mode\r\n\r\n`read_mode` can be set per-query via an optarg to `r.table()`. This replaces the old `use_outdated` optarg.\r\n\r\nThe possible values are:\r\n* `\"majority\"`: The read will only observe values that are safely committed on disk on a majority of replicas. This mode requires sending a message to every replica for each read.\r\n* `\"single\"`: The read will observe values that are in memory on the primary replica. This is the default.\r\n* `\"outdated\"`: The read will observe values that are in memory on an arbitrary replica.\r\n\r\nChangefeeds ignore the `read_mode` flag; their behavior is always equivalent to `\"single\"` mode.\r\n\r\n#### Guarantees\r\n\r\n##### Linearizability and atomicity\r\n\r\nIf `write_acks` is set to `\"majority\"`, `durability` is set to `\"hard\"`, and `read_mode` is set to `\"majority\"`, then RethinkDB guarantees linearizability of individual atomic operations on each individual document. This means that every read will see every previous successful write, and no read will ever see a definitively failed write. (See note about definitively failed vs. indeterminate writes below.)\r\n\r\nWarning: The above linearizability guarantee is for *atomic operations*, not for *queries*. A single RethinkDB query will not necessarily execute as a single atomic operation. For example, `r.table(\"foo\").get(\"bar\").eq(r.table(\"foo\").get(\"bar\"))` might return `false`! Each individual `r.table(\"foo\").get(\"bar\")` operation is atomic, but the query as a whole is not atomic.\r\n\r\nIf you need to read and then modify a document as a single atomic operation, use the `.update()` or `.replace()` commands. For example, to atomically increment the `hits` field of a document, you could write:\r\n```\r\ntable.get(counter_id).update({hits: r.row(\"hits\") + 1})\r\n```\r\nThis can also be used to implement a check-and-set register. For example, the following query will atomically check whether to `foo` field is equal to `old_value` and change it to `new_value` if so:\r\n```js\r\ntable.get(register_id).update({\r\n    foo: r.branch(r.row(\"foo\").eq(old_value), new_value, r.row(\"foo\"))\r\n    })\r\n```\r\n\r\nRethinkDB operations are never atomic across multiple keys. For this reason, RethinkDB is not considered an ACID database.\r\n\r\nCurrently, `.filter()`, `.get_all()` and other such operations will execute as separate atomic operations from `.update()` and other mutation operations. For example, the following is *not* a correct implementation of a check-and-set register:\r\n```js\r\ntable.filter({id: register_id, foo: old_val}).update({foo: new_val})\r\n```\r\nHowever, there has been some discussion of changing this behavior. See https://github.com/rethinkdb/rethinkdb/issues/3992.\r\n\r\n##### Availability\r\n\r\nExcept for brief periods, a table will remain fully available as long as more than half of the replicas for each shard are available, not counting non-voting replicas. If half or more of the voting replicas for a shard are lost, then read or write operations on that shard will fail.\r\n\r\nIf the primary replica is lost, but more than half of the voting replicas are still available, an arbitrary voting replica will be elected as primary. The new primary will show up in `table_status`, but the `primary_replica` field of `table_config` will not change. If the old primary ever becomes available again, the system will switch back. When the primary changes there will be a brief period of unavailability.\r\n\r\nReconfiguring a table (changing the number of shards, shard boundaries, etc.) will cause brief losses of availability at various points during the reconfiguration.\r\n\r\nIf half or more of the voting replicas of a shard are lost, the only way to recover availability is to run the emergency repair command. Running the emergency repair command invalidates the linearizability guarantees in this document.\r\n\r\nBut see https://github.com/rethinkdb/rethinkdb/issues/4357 for an exception / known bug in these availability guarantees.\r\n\r\nReads run in `\"single\"` mode may succeed even if the table is not available, but this is not guaranteed. Reads run in `\"outdated\"` mode will succeed as long as at least one replica for each of the relevant shards is available.\r\n\r\n##### Trading off safety for performance\r\n\r\nRethinkDB offers a sliding scale of safety versus performance guarantees.\r\n\r\nThe default settings always choose safety over performance except in one case: `read_mode` defaults to `\"single\"` rather than `\"majority\"`. This is because `\"majority\"` read mode requires sending a query to all of the replicas and waiting for a majority of them to reply, which significantly degrades performance.\r\n\r\nIn normal operation, `\"single\"` read mode produces the same results as `\"majority\"` read mode during normal operation, but in the event of a network failure or crash, it might return outdated results. It's also possible that a read run in `\"single\"` mode can return results from an incomplete write that is later rolled back.\r\n\r\nThe same is true for `\"single\"` write mode and `\"soft\"` durability mode: in normal operation these produce the same ressults as `\"majority\"` and `\"hard\"`, but in the event of a network or server failure, recent write operations that were run using these modes might be lost.\r\n\r\nNote that `write_acks` and `durability` don't actually affect how the write is performed; they only affect when the acknowledgement is sent back to the client.\r\n\r\nReads run in `\"outdated\"` mode will return outdated data even during normal operation, but the data will typically be less than a second out of date. In the event of a network or server failure, the data may be much more out of date. The advantage of running reads in `\"outdated\"` mode is that the latency and throughput are often better than in `\"single\"` mode, in addition to the availability differences described in the previous section.\r\n\r\n##### Other notes\r\n\r\nIf you run the emergency repair command on a table, these guarantees will be invalidated.\r\n\r\nThere are two ways a write operation can fail. Sometimes it will fail definitively; other times it will fail indeterminately. You can examine the error message to see which type of failure happened. (This is a work in progress; ask @mlucy for details.) If a write fails definitively, no read will ever see it, even in the weaker read modes. If it fails indeterminately, it's in a sort of a limbo state; reads run in `\"single\"` or `\"outdated\"` modes might see it, but when the network failure or crash that caused the problem is resolved, the write might or might not be rolled back. In general, writes will fail indeterminately if they were running at the exact moment when the network or server issue first happened.\r\n\r\n@VeXocide @danielmewes -- please read over this and let me know if you spot any errors or things that are incompletely documented."
  , issueCommentId = 110194224
  }